[TOC]

# 编辑距离

两个字符串之间，由一个字符串转换为另一个字符串所要经过的最小编辑次数。允许的编辑操作包括：替换一个字符、插入一个字符、删除一个字符。（增、删、改）

比如：
kitten与sitting的编辑距离：

> 1. sitten (k -> s)
> 2. sittin (e -> i)
> 3. sitting (添加g)

故，kitten和sitting的编辑距离就是3。

## 编辑距离求解算法

求解思路就是动态规划。定义函数：edit(i,j)，表示长度为i的子串与长度为j的子串之间的编辑距离。

> if i == 0 and j == 0, edit(i,j) = 0
> if i == 0 and j > 0, edit(i,j) = 0
> if i > 0 and j == 0, edit(i,j) = 0
> if i > 0 and j > 0, edit(i,j) = min{edit(i-1,j)+1, edit(i,j-1)+1, edit(i-1,j-1) + f(i,j)}，当第一个字符串的第i个字符不等于第二个字符串的第j个字符时，f(i,j) = 1；否则f(i,j) = 0。

最后一个if中min的三个表达式于修改操作的对应关系：
> edit(i-1,j)+1 -> 对i-1子串做一次修改
> edit(i,j-1)+1 -> 对j-1子串做一次修改
> edit(i-1,j-1) + f(i,j)表示对i或者j子串做修改

注：上面三种情形提到的修改是不确定的，可能是增，也可能是删，也可能是插入，能确定的只有不管哪种操作都是一步的举例。

## C代码实现

```c
#include <stdio.h>
#include <string.h>

int min(a, b, c) {
    int tmp = a > b ? b : a;
    return tmp > c ? c : tmp;
}

int editDistance(char* str_i, char* str_j, int len_i, int len_j) {
    int i, j;
    int m[len_i+1][len_i+1];

    for (i = 0; i <= len_i; i++) {
        m[i][0] = i;
    }

    for (j = 0; j <= len_j; j++) {
        m[0][j] = j;
    }

    for (i = 1; i <= len_i; i++) {
        for (j = 1; j <= len_j; j++) {
            if (str_i[i-1] == str_j[j-1]){
                m[i][j] = m[i-1][j-1];
            }
            else {
                int tmp_1 = m[i-1][j] + 1;
                int tmp_2 = m[i][j-1] + 1;
                int tmp_3 = m[i-1][j-1] + 1;
                d[i][j] = min(tmp_1, tmp_2, tmp_3);
            }
        }
    }

    return m[i][j];
}

```

## Python代码实现

```python

def edit_distance(str_i, str_j):
    len_i = len(str_i)
    len_j = len(str_j)

    m = [0] * ((len_i + 1) * (len_j + 1))

    for j in range(0, len_j+1):
        m[j] = j

    for i in range(0, len_i + 1):
        m[(len_j + 1) * i] = i

    for i in range(1, len_i + 1):
        for j in range(1, len_j + 1):
            if str_i[i-1] == str_j[j-1]:
                m[(len_j+1)*i + j] = m[(len_j+1)*(i-1) + j - 1]
            else:
                tmp_1 = m[(len_j+1)*(i - 1) + j] + 1
                tmp_2 = m[(len_j+1)*i + j - 1] + 1
                tmp_3 = m[(len_j+1)*(i - 1) + j - 1] + 1
                m[(len_j+1)*i + j] = min(tmp_1,tmp_2,tmp_3)

    return m[(len_i+1)*(len_j+1) - 1]

```

## 参考

1. [最小编辑距离](https://blog.csdn.net/baodream/article/details/80417695)
2. [编辑距离与编辑距离算法](https://blog.csdn.net/qq_40685275/article/details/80157005)
