[TOC]

# 协同过滤算法

协同过滤是推荐系统的召回阶段常用的一类方法，协同过滤算法包括：基于用户的协同过滤、基于物品的协同过滤和基于模型的协同过滤(如矩阵分解等)。

## 1. 基于用户的协同过滤

**核心思路**：先找到一个用户A的相似用户，然后把相似用户感兴趣的物品，同时是用户A没有接触过的物品，推荐给用户A。

接下来要解决的问题是：**如何度量用户之间的相似度？**

度量方式还是通过分析用户感兴趣的物品，思路就是如果两个用户都对某个物品感兴趣，那么这两个用户就有相似性，感兴趣的物品越多，相似性越大。

度量相似度的公式：

**Jaccard相似度**：
$$W_{uv} = \frac{|N(u)\cap N(v)|}{|N(u) \cup N(v)|}$$

**余弦相似度**：
$$W_{uv} = \frac{|N(u) \cap N(v)|}{\sqrt {|N(u)||N(v)|}}$$

**变量定义**：$N(u)$和$N(v)$分别表示用户u和v感兴趣物品的集合。对集合加绝对值表示求的是集合元素数量。

**额外说明**：余弦相似度的计算没有使用向量的內积运算，主要是因为用户对物品的兴趣都是0/1变量，表示是否点击过，没有具体量化的评分，所以直接使用集合的运算便可以了，但是也可以表示成向量形式的运算，就是把物品用向量表示，感兴趣的物品对应的位置置为1。

直接使用上面的公式**存在如下问题**：
上面的公式没有考虑物品与物品之间的差异性，有些物品是很大众化的物品，比如每个人都会用到的物品，或者大多数人都会用的物品；还有些物品是一类人群才会使用的；受用群体越小的物品，更能反映两个人的相似性。所以用对物品的受众数量对物品构建一个惩罚因子，这种做法类似于TF-IDF的IDF。

添加惩罚因子的余弦相似度公式：
$$W_{uv} = \frac{\sum_{i\in N(u) \cap N(v)} \frac{1}{log(1+|N(i)|)}}{\sqrt {|N(u)||N(v)|}}$$

其中，$N(i)$表示对物品i有兴趣的人数量。

接下来，**根据人A与人B的相似度，人B对物的兴趣度，计算人A对物的兴趣度**：
$$P_{ui} = \sum_{v \in S(u,K) \cap N(i)} {W_{uv}R_{vi}}$$

其中，$S(u,K)$表示用户$u$最相近的$K$个用户，$N(i)$表示对物品$i$有兴趣的人的集合，$R_{vi}$表示用户$v$对物品$i$的感兴趣度。

## 2. 基于物的协同过滤

UserCF存在**两个缺陷**，当然了，这个缺陷也是针对有些类别的场景才会真的成为缺陷的：

- 如果用户量过大，那么计算用户相似度计算量就会很大；
- 可解释性差，某一方面相似的人，不见得就其他感兴趣的点也相似，特别是电商领域的推荐，UserCF的推荐时常会让人感觉莫名其妙的。

所以，亚马逊公司提出了与UserCF相对的ItemCF算法。

**基本思想**：用户A对物品B感兴趣，那么A就更有可能对于B相似的物品感兴趣。

不过，ItemCF算法并不是通过直接通过物品的属性来计算相似度，而是借助于用户与物品的交互信息来计算物品之间的相似度。算法的思路是：**如果喜欢物品A的用户大都喜欢物品B，那么A和B就有很大的相似度**。

根据上面的思路，给出如下描述物品相似度的公式：

$$W_{ij} = \frac{|N(i) \cap N(j)|}{\sqrt {|N(i)||N(j)|}}$$

其中：$N(i)$表示对物品$i$感兴趣的用户集合，$N(j)$表示对物品$j$感兴趣的用户集合。

上面的公式中每个用户对得分的贡献都是一样的，但是这种做法是有问题的。A和B用户都拥有物品C，但是A和B对物品C的感兴趣程度是不一样的。比如用户A和B都买了一本书C，但是A只买了几十本书，B呢，则是图书馆采购员，B买了上百万的书籍，显然C更能反映A的兴趣，却不能反映B的兴趣。

John S.Breese提出了一个IUF(Inverse User Frequence)的概念，用于越活跃，对物品相似度的共享就会越小。增加了IUF的相似度计算公式如下：

$$W_{ij} = \frac{\sum_{u \in {N(i) \cap N(j)}} \frac{1}{log(1+|N(u)|)}}{\sqrt {|N(i)||N(j)|}}$$

其中，$N(u)$表示用户$u$感兴趣的物品数量。

然后，可以计算用户对物品的相似度：
$$P_{uj} = \sum_{i \in N(u) \cap S(j,K)}W_{ji}R_{ui}$$

其中，$N(u)$表示用户$u$感兴趣的物品集合，$S(j,K)$则表示物品$j$最相似的K个物品的集合。$W_{ji}$表示物品$i,j$的相似度，$R_{ui}$表示用户对物品$i$的兴趣度。

## 3. UserCF与ItemCF对比

先大致梳理一下两种协同过滤策略：

UserCF：User -> User -> Item
ItemCF: User -> Item -> Item

我们从上面的路径中可以发现，UserCF是通过先关联人，在找到推荐Item，它强调的是社交属性的推荐，如果涉及的Item也能体现出“圈子”、“社交”等层面的功能，Item能够体现人与人的关联。还有一点，Item的属性不能很好的反映个体的个性化时，此时，就应该使用UserCF。比如新闻推荐，新闻是具有“话题性”的Item，也就是社交性的Item，用户看新闻，更大的可能希望想看到大家都看到的新闻。

ItemCF推荐则是更加围绕个体，推荐更能体现个性化。你感兴趣啥，我就推荐啥。这种推荐关注用户的个体化的兴趣点，我关心的只是因为我关心，而不是因为其他人关心了，我才需要关心。这样的推荐有更高的精准性和可解释性。**ItemCF是纵深的推荐思路，UserCF是横向扩展的推荐**。ItemCF典型的应用场景比如电商、图书、电影网站等。ItemCF还有一个很大的优点，因为ItemCF是纵深的挖掘兴趣，所以可以挖掘长尾的物品。

除了上面的对比维度，还有一点，**稳定性**。比如新闻场景，新闻更新速度很快，我们很难立马对某个新闻计算与其他新闻的相似度，但是人与人的相似度更为稳定，所以通过人的关联来推荐新闻，更为简单，所以UserCF的方式更为合理。对于电商或者电影网站等场景，人的兴趣相对更为稳定，User -> Item这一层是稳定的，至少是阶段性稳定的，网站的物品通常更新速度也不是很快的。所以更适合使用ItemCF算法。

UserCF和ItemCF比较完整的对比：

1. 性能比较

- UserCF: 适用于用户较少的场合，用户太对，通过矩阵计算相似度成本高；
- ItemCF: 适用于物品明显小于用户数的场合，物品过多，计算代价也很大；

2. 领域

- UserCF: 适用于时效性较强，用户个性兴趣不太明显的领域；
- ItemCF: 适用长尾物品丰富，用户个性化需求强烈的领域；

3. 实时性

- UserCF: 用户有新行为，不一定造成推荐结果变化；
- ItemCF: 用户有新行为，一定会倒置推荐结果的实时变化；

4. 冷启动

- UserCF: 1). 新用户上线，无法立即产生推荐行为；2). 新物品上线，只要被用户产生了点击等行为，可以立即被推荐给其他用户；
- ItemCF: 和UserCF相反，新用户上线，只要操作了物品，就会产生推荐；但是新物品上线，不能立刻产生推荐。

## 4. 基于模型的协同过滤

## 参考

1. [协同过滤——基于模型的算法](https://blog.csdn.net/jediael_lu/article/details/93632653)
