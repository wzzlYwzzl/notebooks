[TOC]

# 使用Keras的Sequential模型

## 在Sequential模型中添加layer

有两种方式，一种是直接传入一个包含layer的list，另一种是通过.add()方法。

```python
from keras.models import Sequential
from keras.layers import Dense, Activation

model = Sequential([
    Dense(32, input_shape=(784,)),
    Activation('relu'),
    Dense(10),
    Activation('softmax'),
])

# 下面是另一种方式
model = Sequential()
model.add(Dense(32, input_dim=784))
model.add(Activation('relu'))

```

## 指定输入的形状

模型需要知道输入的形状，模型的第一层需要传入shape信息，其他层会自动推理输入shape信息。指定输入shape有以下几种方式：

- 传入一个input_shape参数，它是一个整数tuple。input_shape中不包含batch纬度的信息。
- 一些2D的层，比如Dense，支持通过input_dim来指定shape。一些3D的层支持通过input_dim和input_length来指定shape。
- 如果需要指定固定的batch_size，那么可以给该层传入batch_size参数。

## Compilation

在训练模型之前，需要配置学习过程，这通过compile方法完成。compile方法有三个参数：

- 一个optimizer。它可以是一个字符串，来表示已经实现的optimizer，也可以是Optimizer类的一个实例。
- 一个损失函数。它是模型要最小的目标函数。它也可以是一个字符串来表示已经实现的损失函数，也可以是一个目标函数。
- metrics的列表。metric可以是一个字符串，指示已经实现的metric，也可以是metric函数。

```python
# 对于多分类任务
model.compile(
    optimizer='rmsprop',
    loss='categorical_crossentropy',
    metrics=['accuracy']
)

# 对于二分类任务
model.compile(
    optimizer='rmsprop',
    loss='binary_crossentropy',
    metrics=['accuracy']
)


model.compile(
    optimizer='rmsprop',
    loss='mse'
)

# 自定义metrics

import keras.backend as K

def mean_pred(y_true, y_pred):
    return K.mean(y_pred)

model.compile(
    optimizer='rmsprop',
    loss='binary_crossentropy',
    metrics=['accuracy', mean_pred]
)

```

## Training

Keras的训练数据是numpy的arrays，通过调用fit函数来进行训练。
