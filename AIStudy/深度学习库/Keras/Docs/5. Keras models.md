[TOC]

# Keras的model

Keras有两类model，Sequential模型和functional API使用的模型。

这两种模型都有下面的公用方法：

- model.layers: 扁平化的模型层信息。
- model.inputs: model的输入tensor列表。
- model.outputs: model的输出tensor列表。
- model.summary(): 打印出模型的摘要信息。如果是多个输出的layer，那么会输出"multiple"，而不是输出每一个output的shape，这是为了节省空间。
- model.get_config(): 返回一个dict，其中包含了模型的配置信息。
- model.from_config(dict): 读取dict，配置模型。与get_config方法对应。
- model.get_weights(): 返回模型的权重tensor。
- model.set_weights(weights): 设置模型的权重。
- model.to_json(): 返回模型的表示为json字符串。

```python
from keras.models import model_from_json

json_string = model.to_json()
model = model_from_json(json_string)
```

- model.to_yaml(): 将模型的表示转换为yaml字符串。

```python
from keras.models import model_from_yaml

yaml_string = model.to_yaml()
model = model_from_yaml(yaml_string)
```

- model.save_weights(filepath): 保存模型的权重为HDF5文件。
- model.load_weights(filepath, by_name=False): 从HDF5文件中加载模型的权重。默认情况下，模型的架构是应该相同的，但是如果加载到不同的架构，但是有些层是相同的，那么需要by_name=True，这样会加载layer的名字相同的权重。

## 继承Model类

通过继承Model类可以创建完全自定义的model。

下面是一个简单的多层感知机的例子，它是通过继承Model类来实现的：

```python
import keras

class SimpleMLP(keras.Model):
    def __init__(self, use_bn=False, use_dp=False, num_classes=10):
        super(SimpleMLP,self).__init__(name='mlp')
        self.use_bn = use_bn
        self.use_dp = use_dp
        self.num_classes = num_classes

        self.dense1 = keras.layers.Dense(32, activation='relu')
        self.dense2 = keras.layers.Dense(num_classes, activation='softmax')

        if self.use_dp:
            self.dp = keras.layers.Dropout(0.5)

        if self.use_bn:
            self.bn = keras.layers.BatchNormalization(axis=-1)

    def call(self, inputs):
        x = self.dense1(inputs)
        if self.use_dp:
            x = self.dp(x)
        if self.use_bn:
            x = self.bn(x)
        return self.dense2(x)

model = SimpleMLP()
model.compile(...)
model.fit(...)
```

层信息在__init__函数中定义，call方法中定义前向传播过程。

继承Model类的模型，由于model的拓扑结构是在python代码中定义的，而不是静态的层与层的图，所以model的结构是无法查看和序列化的。这也意味着下面的这些方法是不能使用的：

- model.inputs 和 model.outputs
- model.to_yaml() 和 model.to_json()
- model.get_config() 和 model.save()

继承Model类提供了很大的灵活性，可以允许你实现复杂的模型，但是也是有代价的，更冗长、复杂，更容易出错。所以，如果可能尽量还是使用functional API，它对用户更友好。
