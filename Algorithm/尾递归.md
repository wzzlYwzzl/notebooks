[TOC]

# 尾递归

## 1. 递归

递归，是一种常用的编程技巧，使用递归的核心思想就是将问题分解，通过不断解决同质的小问题，然后处理小问题的结果，最后得到最终的结果。能够使用“分治法”的问题，同常都可以使用递归解决问题。

所以，通常我们使用递归时，都是递归调用函数，得到结果，然后再处理结果。

```python
def f():
    # do something，包括判断终止条件
    v = f()
    # do another thing with v
    return something
```

上面给出了递归问题的笼统范式，从中我们可以发现，递归调用函数时涉及**返回地址**、**函数参数**、**寄存器值**的压栈和出栈操作。这也是为什么递归方法通常效率要低于非递归方法的原因，甚至一不小心还有可能造成栈溢出的问题。

## 2. 特殊递归——尾递归

尾递归，顾名思义，就是在函数的末尾调用函数本身。

```python
def f(v1,v2):
    # do something
    return f(v3,v4)
```

当编译器检测到尾递归时，由于尾部函数返回时原来函数已经没有其他操作了，所以也就没有必要保存函数上下文信息，所以也就没有必要压栈操作了。编译器直接会直接覆盖当前函数调用使用的栈帧。

## 3. 一个简单的例子

求1 + ... + n的值，用递归的方式。

```python
def f(n):
    if n == 0:
        return 0
    else:
        return n + f(n-1)
```

如果将上面的函数改成尾递归的方式，代码如下：

```python
def f(n, tmp_total):
    if n == 0:
        return 0
    else:
        return f(n-1, tmp_total + n)
```

## 4. 深入思考

**1. 是不是所有的递归都可以改造成尾递归？**
这个问题有点复杂，暂时不做解答了，后面有时间时，再细细思考。

**2. 关于尾递归的一点思考**
尾递归等价于一个无栈的循环，所有尾递归同常没有意义。

尾递归调用时，都将当前的**局部结果带入到新的函数调用中**，这样就无需函数返回之后进行其他操作。
