[TOC]

# 冒泡排序

冒泡排序的做法就是两两，比如位置$i,i+1$比较，如果位置不合理，就进行交换，然后再比较$i+1,i+2$，一趟完成后，得到一个最大或者最小的元素。

这个过程类似于气泡从水中冒出，因为压强越来越小，气泡酒越来越大。这也是这个排序算法形象化名称的缘由。

## 1. 常规冒泡排序

![1](./images/冒泡排序/1.gif)

这里直接给了一个图示说明，不再用不直观的文字描述。

## 2. 初步优化冒泡排序

先说为什么需要优化，假设我们要从小到大排序，给定的数组为：1，3，2，4，5。
我们发现，经过一次冒泡之后，序列为1，2，3，4，5。但是，按照常规的冒泡排序算法，我们仍需要继续两两比较，知道最后只剩下一个，无法完成交换为止。

但是，其实我们在完成一次冒泡交换后，没有必要在进行后面的交换了。如何判断是否需要后面的交换呢？

设置一个标志，**如果一次冒泡过程如果没有发生任何交换**，那么说明已经有序了，就不再需要进行后续的操作了。

## 3. 进一步优化冒泡排序

上面已经进行了初步的优化，效果已经好了很多，但是，还有优化的空间。

比如，下面的序列，我们需要从小到大排序：3,2,5,7,1,6,9,10,11。

进行第一轮的冒泡排序后：2,3,5,1,6,7,9,10,11
进行第二轮的冒泡排序后：2,3,1,5,6,7,9,10,11

我们可以发现，要排序的序列的后面的元素都已经是有序的了，每次冒泡还是要对后面部分进行比较，这其实也是不必要的。

如何优化？

我们每一轮冒泡排序时，都去标记最后一个进行数据交换的位置，那么下一轮冒泡排序时，到上一轮的最后一次交换的位置时，就不再进行交换就可以了。

## 4. 复杂度分析

**时间复杂度：**
最好：$O(N)$
最坏：$O(N^2)$
平均：$O(N^2)$

**空间复杂度：**
O(1)

**稳定性：**
稳定

## 5. 冒泡排序与选择排序

选择排序永远是比较待排序序列中的元素和第一个元素，如果需要交换，就交换数据，这样的比较逻辑是无法确定待排序列内部的有序性的。所以，选择排序的算法复杂度永远是$O(n^2)$。

但是，冒泡排序算法是比较相邻的两个元素，我是可以通过是否发生了交换来确定两个待排序序列内部的有序性的。比如，如果冒泡过程中，为发生交换行为，就说明数据已经有序了，那么就不需要进行下一轮的排序了。

## 参考

1. [冒泡排序及优化详解](https://www.cnblogs.com/jyroy/p/11248691.html)
