[TOC]

# 希尔排序

希尔排序(Shell Sort)是以它的发明者Donald Shell的名字命名的，于1959年提出。希尔排序也是一种插入排序，它是简单插入排序经过改进之后的一个更高效的版本，也称为缩小增量排序，同时该算法是冲破$O(n^2)$的第一批算法之一。

## 1. 算法介绍

希尔排序核心思想就是将待排序的数据分组，在组内通过插入排序算法进行排序。但它分组的方式特别一些，通过一定的**步长**，或者说**增量**来分组。随着分组变少，每组的元素数量增多，至分成一组便结束分组。

接下来我们介绍shell排序算法的步骤：

**确定增量序列**，同时也就是确定分组数量。假设我们要排列的序列的长度为：len，那么我们常用的增量序列是gap = len/2, gap = gap/2, ...，gap值就是分组的数量。希尔排序的增量序列的选择与证明是个数学难题，我们选择的这个增量序列是比较常用的，也是希尔建议的增量，称为希尔增量，但其实这个增量序列不是最优的。

shell排序算法的具体过程如下例子所示：
![2](./images/希尔排序/2.png)

用动态图表示希尔排序算法排序过程如下：
![1](./images/希尔排序/1.gif)

## 2. 时间复杂度

shell排序算法的时间复杂度是一个很复杂的问题，证明也属于比较困难的事情，有些增量序列的时间复杂度也没有得到证明。

shell排序的时间复杂度是和增量序列有关：

- 前面举例使用的增量序列：{n,n/2,n/2/2,...}，最坏情形的复杂度是$O(n^2)$;
- Hibbard提出的另一个增量序列：{1,3,7，...,2^k-1}，这种序列的时间复杂度(最坏情形)为$ O(n^{1.5}) $；
- Sedgewick提出了几种增量序列，其最坏情形运行时间为$O（n^{1.3}）$,其中最好的一个序列是{1,5,19,41,109,...}。

**注意**：序列都是总大到小的，这样才能达到优化的效果。

## 3. 空间复杂度

空间复杂度就是插入排序的复杂度，为$O(1)$。

## 4. 稳定性

虽然插入排序时稳定的，但是shell排序是子序列内部插入，但是子序列是跳跃的，所以是**不稳定**的。

## 5. 希尔排序对比插入排序

先简单说一下二者之间的区别与联系，后面再直观上分析一下为什么这种“跳跃”分组的插入排序能够比单纯的插入排序效果好。

- shell排序是插入排序的改进，其内部也是插入排序；
- 复杂度上：插入排序最差$O(n^2)$，最好$O(n)$；shell排序取决于增量序列；
- 空间复杂度二者相同；

我们直观上分析一下shell排序为什么比插入排序效果好：

我们有一个比较极端的要排序的序列[10,9,8,7,6,5,4,3,2,1]，我们希望从小到大排序。我们只看其中两端的1，如果使用简单的插入排序，它们要经过n-1次的数据交换和对比才能找到自己的位置。而当我们使用shell排序，由于使用的是跳跃分组，那么1所在的组其实不是和它相连的元素，那么这样组内交换就会直接跳跃到相差几步的位置，相比普通插入排序明显节省了不少步骤。

从上面的举例，我们大致能感受到shell排序的作用体现在哪：

为了说明问题，我们先做一个简单的定义：我们把一个无序序列中的某个元素到自己在最终有序序列中的位置的距离大小定义为这个元素的**无序度**，(瞎定义的)，那么一个无序列大概率会存在这种无序度很大的情况，所以shell排序也**大概率**能够起到更好的作用。

## 参考

1. [图解排序算法(二)之希尔排序](https://www.cnblogs.com/chengxiao/p/6104371.html)
2. [希尔排序--简单易懂图解](https://blog.csdn.net/qq_39207948/article/details/80006224)
3. [五分钟学会一个高难度算法：希尔排序](https://www.jianshu.com/p/40dcc3b83ddc)
