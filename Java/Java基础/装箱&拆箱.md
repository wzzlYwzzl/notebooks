[TOC]

# Java 装箱与拆箱

Java 语言中定义了 8 种基本数据类型：int、long、short、byte、float、double、char、boolean。

与这 8 中基本类型对应的还有 8 种**装箱类型**：Integer、Long、Short、Byte、Float、Double、Character、Boolean。

为什么会设计装箱类型呢？

这就要从 Java 管理的两种内存说起，在 Java 中，有两种内存空间：栈内存和堆内存。在这两个内存空间中分配的对象的内存管理方式是不一样的，在栈中分配的变量，当函数退出时就会被回收，而在堆中分配的对象，则是有 Java 的垃圾回收器按照相应的策略进行回收。

对于函数中声明的基本类型，Java 都是在栈中创建的，直接存储数值到栈中，如果没有装箱类型，就会出现问题。

```java
public Test {
    public List<Integer> abc() {
        int a = 10; // 存在于栈空间

        List<Integer> list = ArrayList<Integer>();
        list.add(a); // 由于list是存在于堆空间的，这里如何处理a呢？
    }
}
```

在上面的代码中，我们将一个栈空间的数据 a 添加到堆空间的 List 中，那么 int 类型的 a 在堆空间中对应的对象是什么呢？在堆空间中创建的对象，我们在函数中使用时都是获取其对应的引用。为了能够满足类似于上面代码的需求，所以出现了装箱类型。

## 1. 什么是装箱和拆箱？

**装箱**：基本类型 $\rightarrow$ 装箱类型。
**拆箱**：装箱类型 $\rightarrow$ 基本类型。

```java
Integer a = 10; // 这里包含装箱操作

int b = a; // 这里包含拆箱操作
```

装箱操作是通过 `valueOf` 方法实现的，拆箱方法则是通过装箱类的 `xxxValue`。

## 2. 面试中相关问题

### 2.1 理解并解释下面代码

```java
public class Main {
    public static main(String[] args) {
        Integer i1 = 100;
        Integer i2 = 100;
        Integer i3 = 200;
        Integer i4 = 200;

        System.out.println(i1 == i2); // true
        System.out.println(i3 == i4); // false
    }
}
```

为什么会出现这样的结果？输出结果表明 i1 和 i2 指向的是同一个对象，而 i3 和 i4 指向的是不同的对象.

只需一看源码便知究竟，下面这段代码是 Integer 的 valueOf 方法的具体实现.

在通过 valueOf 方法创建 Integer 对象的时候，如果数值在[-128,127]之间，便返回指向 IntegerCache.cache 中已经存在的对象的引用；否则创建一个新的 Integer 对象。

上面的代码中 i1 和 i2 的数值为 100，因此会直接从 cache 中取已经存在的对象，所以 i1 和 i2 指向的是同一个对象，而 i3 和 i4 则是分别指向不同的对象。

**Integer、Short、Byte、Character、Long 这几个类的 valueOf 方法的实现是类似的。**

**Double、Float 的 valueOf 方法的实现是类似的，它们没有缓存一些简单类型。**

### 2.2 谈谈 Integer i = new Integer(xxx)和 Integer i =xxx;这两种方式的区别

1）第一种方式不会触发自动装箱的过程；而第二种方式会触发；

2）在执行效率和资源占用上的区别。第二种方式的执行效率和资源占用在一般性情况下要优于第一种情况（注意这并不是绝对的）。

### 2.3 解释下面代码的行为

```java
Integer a = 1;
Integer b = 2;
Integer c = 3;
Integer d = 3;
Integer e = 321;
Integer f = 321;
Long g = 3L;
Long h = 2L
System.out.println(c==d); // true
System.out.println(e==f); // false
System.out.println(c==(a+b)); // true
System.out.println(c.equals(a+b)); // true，会触发拆箱操作a+b，然后再进行装箱操作。
System.out.println(g==(a+b)); // true，比较值，故相等
System.out.println(g.equals(a+b)); // false，a+b拆箱后运算结果类型为int，装箱调用的是Integer.valueOf，所以前后类型不相同。
System.out.println(g.equals(a+h)); // true，a+h，拆箱后是int + long，故输出为long，调用的装箱时Long.valueOf
```

**核心要点**：当 "=="运算符的两个操作数都是包装器类型的引用，则是比较指向的是否是同一个对象，而如果其中有一个操作数是表达式（即包含算术运算）则比较的是数值（即会触发自动拆箱的过程）。另外，对于包装器类型，equals 方法并不会进行类型转换。
