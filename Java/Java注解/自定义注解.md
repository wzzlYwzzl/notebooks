[TOC]

# Java自定义注解 @interface

注解就是一个标记，在包、类、方法、属性等等上添加注解，就是为它们添加一个标记。这个标记不会自动产生任何作用，会由其他程序通过反射机制来获取程序中的标记，根据标记来决定接下来是否需要做进一步的处理。

比如我们常见的三中注解：@Override、@Deprecated、@SuppressWarnings。

- 注解@Override用在方法上，当我们想重写一个方法时，在方法上加@Override，当我们方法的名字出错时，编译器就会报错。

- 注解@Deprecated，用来表示某个类的属性或方法已经过时，不想别人再用时，在属性和方法上用@Deprecated修饰。

- 注解@SuppressWarnings用来压制程序中出来的警告，比如在没有用泛型或是方法已经过时的时候。

## 1. 自定义注解

先来一个简单的例子：

```java
@Retention(RetentionPolicy.RUNTIME)
public @interface MyAnnotation {
}
```

如此，就可以在程序中使用@MyAnnotation注解了，是不是简单到吓人。

## 2. @Retention

它是注解的注解，它决定了注解的存在时间。

它有一个value属性，RententionPolicy枚举类型的数据，指定注解信息保留的时间。枚举值有三个：

- @Retention(RetentionPolicy.CLASS)修饰的注解，表示注解的信息被保留在class文件(字节码文件)中当程序编译时，但不会被虚拟机读取在运行的时候；

- @Retention(RetentionPolicy.SOURCE)修饰的注解,表示注解的信息会被编译器抛弃，不会留在class文件中，注解的信息只会留在源文件中；

- @Retention(RetentionPolicy.RUNTIME)修饰的注解，表示注解的信息被保留在class文件(字节码文件)中当程序编译时，会被虚拟机保留在运行时，所以他们可以用反射的方式读取。RetentionPolicy.RUNTIME 可以让你从JVM中读取Annotation注解的信息，以便在分析程序的时候使用。

## 3. 为注解添加属性

在开始的那个例子基础上添加属性：

```java
@Retention(RetentionPolicy.RUNTIME)  
public @interface MyAnnotation  
{  
  String hello() default "gege";  
  
  String world();  
  
  int[] array() default { 2, 4, 5, 6 };  
  
  EnumTest.TrafficLamp lamp() ;  
  
  TestAnnotation lannotation() default @TestAnnotation(value = "ddd");  
  
  Class style() default String.class;  
}  
```

上面程序中，定义一个注解@MyAnnotation，定义了6个属性，他们的名字为：  

hello,world,array,lamp,lannotation,style.  

- 属性hello类型为String,默认值为gege;
- 属性world类型为String,没有默认值;
- 属性array类型为数组,默认值为2，4，5，6;
- 属性lamp类型为一个枚举,没有默认值;
- 属性lannotation类型为注解,默认值为@TestAnnotation，注解里的属性是注解;
- 属性style类型为Class,默认值为String类型的Class类型;

可以以如下方式使用：

```java
@MyAnnotation(hello = "beijing", world="shanghai",array={},lamp=TrafficLamp.RED,style=int.class)  
public class MyTest  
{  
    @MyAnnotation(lannotation=@TestAnnotation(value="baby"), world = "shanghai",array={1,2,3},lamp=TrafficLamp.YELLOW)  
    @Deprecated  
    @SuppressWarnings("")  
    public void output()  
    {  
        System.out.println("output something!");  
    }  
}
```

## 4. 读取注解信息

读取上面的例子：

```java
public class MyReflection  
{  
    public static void main(String[] args) throws Exception  
    {  
        MyTest myTest = new MyTest();  
        Class<MyTest> c = MyTest.class;  
        Method method = c.getMethod("output", new Class[] {});  
       //如果MyTest类名上有注解@MyAnnotation修饰，则为true  
        if(MyTest.class.isAnnotationPresent(MyAnnotation.class))  
        {  
            System.out.println("have annotation");  
        }  

        if (method.isAnnotationPresent(MyAnnotation.class))  
        {  
            method.invoke(myTest, null); //调用output方法
            //获取方法上注解@MyAnnotation的信息  
            MyAnnotation myAnnotation = method.getAnnotation(MyAnnotation.class);  

            String hello = myAnnotation.hello();  
            String world = myAnnotation.world();  
            System.out.println(hello + ", " + world);//打印属性hello和world的值  
            System.out.println(myAnnotation.array().length);//打印属性array数组的长度  
            System.out.println(myAnnotation.lannotation().value()); //打印属性lannotation的值  
            System.out.println(myAnnotation.style());  
        }  

        //得到output方法上的所有注解，当然是被RetentionPolicy.RUNTIME修饰的  
        Annotation[] annotations = method.getAnnotations();  
        for (Annotation annotation : annotations)  
        {  
            System.out.println(annotation.annotationType().getName());  
        }  
   }  
}
```

上面程序的输出：

```txt
have annotation  
output something!  
gege, shanghai  

baby  
class java.lang.String  
com.heima.annotation.MyAnnotation  
java.lang.Deprecated
```

**注意**：如果注解中有一个属性名字叫value,则在应用时可以省略属性名字不写。

## 5. 限定注解的位置

默认情况，对注解的位置是不做限制的，可以用在类、方法、属性上。我们可以通过@Target注解来约束创建的注解的位置。

- ElementType.ANNOTATION_TYPE 可以给一个注解进行注解
- ElementType.CONSTRUCTOR 可以给构造方法进行注解
- ElementType.FIELD 可以给属性进行注解
- ElementType.LOCAL_VARIABLE 可以给局部变量进行注解
- ElementType.METHOD 可以给方法进行注解
- ElementType.PACKAGE 可以给一个包进行注解
- ElementType.PARAMETER 可以给一个方法内的参数进行注解
- ElementType.TYPE 可以给一个类型进行注解，比如类、接口、枚举

## 6. 其他的元注解

元注解有 @Retention、@Documented、@Target、@Inherited、@Repeatable 5 种，前面已经介绍了两种，接下来介绍另外的三种：

@Documented
顾名思义，这个元注解肯定是和文档有关。它的作用是能够将注解中的元素包含到 Javadoc 中去。

@Inherited
Inherited 是继承的意思，但是它并不是说注解本身可以继承，而是说如果一个超类被 @Inherited 注解过的注解进行注解的话，那么如果它的子类没有被任何注解应用的话，那么这个子类就继承了超类的注解。

@Repeatable
Repeatable 自然是可重复的意思。@Repeatable 是 Java 1.8 才加进来的，所以算是一个新的特性。

```java
@interface Persons {
    Person[]  value();
}

@Repeatable(Persons.class)
@interface Person{
    String role default "";
}

@Person(role="artist")
@Person(role="coder")
@Person(role="PM")
public class SuperMan{
}
```

## 参考

1. [Java 自定义注解&通过反射获取类、方法、属性上的注解](https://blog.csdn.net/qq_28016751/article/details/83585614)
