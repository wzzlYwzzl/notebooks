[TOC]

# Spring MVC 过滤器

Filter，过滤器，过滤器使用filter实现，拦截的是request请求，基于回调，基于servlect规范。

依赖容器，有初始化方法和销毁方法，拦截的是地址，粒度很大。

过滤器通过实现Filter接口，实现了过滤器的三个方法，分别是初始化方法，dofilter方法和销毁方法，随着容器的启动和销毁而初始化和销毁，依赖于servlet容器，过滤器拦截的是地址栏请求，过滤器实在进入容器后执行的servlet之前后执行，针对的在处理业务之前的操作。

## 1. 过滤器例子

通过下面的例子，应该更容易理解上面关于Filter的表述。

```java
public class Filter1 implements Filter {

    public void destroy() {
        // TODO Auto-generated method stub
        System.out.println("过滤器1销毁方法");
    }

    public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain)
            throws IOException, ServletException {
        // TODO Auto-generated method stub
        System.out.println("过滤器1，客户端向Servlet发送的请求被我拦截到了，设置请求编码");
        chain.doFilter(request, response);
        System.out.println("过滤器1，Servlet向客户端发送的响应被我拦截到了，设置相应编码");
    }

    public void init(FilterConfig filterConfig) throws ServletException {
        // TODO Auto-generated method stub
        System.out.println("过滤器1初始化方法");
    }

}
```

## 2. 与拦截器对比

拦截器是基于Java的jdk动态代实现的，实现HandlerInterceptor接口。不依赖于servlet容器，

拦截器针对于contraller方法，并且能获取到所有的类，对类里面所有的方法实现拦截，粒度更小，拦截器中**可以注入service**，也可以调用业务逻辑。

**两者的对比：**

- 两者都是AOP编程思想的实现，都能够实现权限控制和日志记录等问题的处理，但是两者粒度不同拦截对象不一样

- 适用范围不同：**Filter是servlet的规范，只能用于web程序**，但是拦截器可以用于application等程序。

- 规范不同：Filter是servlet的规范。但是Interceptor是spring容器支撑，有spring框架支持。

- 使用资源不一样：spring的拦截器由于依赖spring，也是spring的一个组件，因此能够在拦截器中使用spring的任何资源和对象。例如service对象，数据源，事务管理等，通过ioc注入拦截器即可，而filter不能

- 粒度不同：**Filter只能在servlet的前后起作用**，而**拦截器能在方法前后异常前后执行**，更加灵活，粒度更小，spring框架程序优先使用拦截器。
