[TOC]

# 乐观锁与悲观锁

这里的乐观和悲观，是在面对共享资源时，对场景做的假设不同。乐观体现在认为共享资源在自己访问的时候被修改的概率比较低。悲观则是认为访问共享资源时，认为资源被修改的概率很高。

由于对问题的假设不同，所以采用的锁的机制分别称为乐观锁和悲观锁。

## 1. 乐观锁

每次去那数据的时候，不会对资源上锁，但是在更新的时候，会判断此期间别人是否更新了这个数据。可以使用版本号机制或者CAS(compare and swap)来实现。

乐观锁适用于多读的应用场景，可以提高吞吐量。

比如：数据库中提供的write_condition机制就是用乐观锁。还有Java的concurrent.atomic包下面的原子操作也是使用乐观锁，实现方式是CAS方式。

## 2. 悲观锁

每次拿数据时，都会上锁，这样别人想拿到这个数据就会阻塞。共享资源每次都只能有一个线程在使用。传统关系数据库中很多地方用到了这种锁机制，比如：行锁、表锁、读锁、写锁等。Java中的synchronized和ReentrantLock都是悲观的独占锁。

## 3. 乐观锁的两种实现方式

### 3.1 版本号机制

给共享数据加上一个版本号version字段，表示当前数据的修改次数。如果数据被修改version就会增加1。一个线程修改它时，会同时读取这个版本，修改好后，在要修改数据时再次获取这个version号，如果一致则进行修改，否则修改失败，重新执行修改操作。

### 3.2 CAS算法

Compare and Swap，一种有名的无锁算法。无锁编程，就是在不使用锁的情况下实现多线程之间的变量同步。CAS涉及三个操作数：

- 需要读写的内存值V
- 进行比较的值A
- 拟写入的新值B

仅当V和A的值相同时，才用B替换V。CAS通过原子的方式完成数据的更新操作，比较和替换操作都是原子操作。如果不相等，就会进行自旋操作，即不断的重试。

## 4. 乐观锁的缺点

### 4.1 ABA问题

一个变量修改前得到的值是A，当准备修改时，检查它的值仍然是A，但是这并不能表明这个变量没有被修改过，有可能是这个变量被修改了一到多次后，最后一次修改后的值仍是A而已。这就是ABA问题。

JDK 1.5以后，提供了AtomicStampedReference类可以解决这个问题。其中compareAndSet方法就是检查当前引用是否等于预期引用，并且当前标志是否等于预期的标志，如果全部相等，则以原子的方式将该引用和该标志设置为给定的更新值。

### 4.2 循环时间长开销大

自旋CAS如果长时间不成功，会给CPU带来非常大的开销。

如果JVM支持处理器提供的pause指令，那么效率会得到提升。pause指令有两个作用：1. 它会延迟流水线执行指令，使CPU不会消耗过多的执行资源，延迟的时间取决于具体实现的版本；2. 可以避免在退出循环的时候因内存顺序冲突而引起CPU流水线被清空，从而提高CPU的执行效率。

### 4.3 只能保证一个共享变量的原子操作

CAS只对单个共享变量有效，当涉及多个变量时CAS就无效了。但从JDK1.5开始，提供了AtomicReference类来保证引用对象的原子性，所以可以将多个变量放到一个对象中来实现多个变量的共享。

## 5. Java的synchronized的实现方式

具体内容参考[Java目录下的内容](../Java/Synchronized原理.md)
