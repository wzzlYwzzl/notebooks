[TOC]

# 在JSX中处理样式

下面列出的过程对应的简单demo在React的demo目录中可以查看。

## 1. 创建目录

在src下面创建css目录，所有样式文件放到css目录下。

## 2. 安装配置插件

cnpm i style-loader css-loader -D

配置webpack.config.js

```js
const path = require("path");
const HtmlWebPackPlugin = require("html-webpack-plugin");

//创建一个插件实例
const htmlPlugin = new HtmlWebPackPlugin({
  template: path.join(__dirname, "./src/index.html"),
  filename: "index.html",
});

module.exports = {
  mode: "development",
  plugins: [htmlPlugin],
  module: {
    //第三方模块的配置规则
    rules: [
      //第三方匹配规则
      { test: /\.js|jsx$/, use: "babel-loader", exclude: /node_modules/ }, //必须要添加exclude配置项
      { test: /\.css$/, use: ["style-loader", "css-loader"] },
      {
        test: /\.scss$/,
        use: [
          "style-loader",
          {
            loader: "css-loader", // options中的内容很关键，用于为css生成对象，以限制作用域
            options: {
              modules: { localIdentName: "[path][name]-[local]-[hash:5]" },
            },
          },
          "sass-loader",
        ],
      },
    ],
  },
  resolve: {
    extensions: [".js", ".jsx", ".json"], //表示这几类文件后缀可以省略
    alias: {
      "@": path.join(__dirname, "./src"),
    },
  },
};

```

## 3. 使用自己项目的样式表

在./src/css目录添加相应的css文件，在文件中创建相应的样式。

### 3.1 在jsx文件中引入css文件

```js
{ test: /\.css$/, use: ["style-loader", "css-loader"] }
```

上面这种方式配置的css loader方式，可以直接使用css的样式内容的，如何使用呢？

```js
import '@/css/xxx.css'
```

但是，这种做法有一个问题，就是这种方式引入的样式配置是全局作用域，就是整个项目都会使用使用的相应css样式，这样会导致冲突问题，如何解决这个冲突问题呢？

react的解决方式需要借助于配置css-loader来实现。

```js
{
        test: /\.css$/,
        use: [
          "style-loader",
          {
            loader: "css-loader", // options中的内容很关键，用于为css生成对象，以限制作用域
            options: {
              modules: { localIdentName: "[path][name]-[local]-[hash:5]" },
            },
          }
        ],
      },
```

将之前webpack.config.js的module.rules中的关于css的配置改成如上面的形式。

简单解释一下对应的含义：

modules表示启用css的模块化，这样css-loader就会为每个样式生成一个随机的不会重复的ID，这样的随机化ID不利于人阅读，所以通过localIdentName配置来指定每个样式的名字的生成规则。

- [path]：样式文件的路径，路径是从项目根目录开始的。
- [name]：样式文件的名称
- [local]：样式文件的样式的名字
- [hash:length]：随机的数字，默认是32字节，可以通过length来限制取值长度，一般5~6即可。

经过上面的配置之后，如何引入css文件呢？

```js
// cssobj只是随便起的名字
import cssobj from '@/css/xxx.css'
```

下面给出一个jsx文件中的使用例子：

```js
import React from "react";

//注意此时cssobj是一个对象，是由一堆的key:value，可以就是样式文件中样式的名字
import cssobj from '@/css/cmtitem.css'

function CmtItem(props) {
  return (
    <div className={cssobj.cmtbox}>
      <h1 className={cssobj.title}>评论人：{props.user}</h1>
      <p>评论内容：{props.content}</p>
    </div>
  );
}

export default CmtItem;
```

上面例子对应的css文件内容如下：

```css
.title {
    font-size: 20px;
}

.content {
    font-size: 12px;
}

.cmtbox {
    border: 1px dashed #ccc;
    margin: 10px;
    padding: 10px;
    box-shadow: 0 0  10px #ccc;
}
```

### 3.2 为样式配置是否模块化

css-loader为我们提供了两个参数用于指定是否模块化：

- :local()，它包括的样式配置项会被模块化，局部有效，只能通过className={cssobj.xxx}使用。
- :global()，它包括的样式配置项不会被模块化，会全局有效；

```css
.title {
    font-size: 20px;
}

.content {
    font-size: 12px;
}

/*这样cmtbox就是全局的，可以在样式中直接使用<div className='cmtbox'></div>来使用样式*/
:global(.cmtbox) {
    border: 1px dashed #ccc;
    margin: 10px;
    padding: 10px;
    box-shadow: 0 0  10px #ccc;
}
```

## 4. 使用第三方样式表

上面提到的做法对于使用自己项目的css是没有问题的，但是如果我们要使用第三方的样式文件呢？比如我们要使用bootstrap的样式文件。

注意：在react项目中使用bootstrap应该使用`cnpm i react-bootstrap bootstrap -S`，此时是不会有问题的。但这里我们是为了说明问题，所以这里可以使用bootstrap@3.3.7来验证这个问题。

如果我们已经用上面介绍的关于css的配置，那么就会导致bootstrap的css文件也会模块化，导致使用的时候会麻烦很多，没有原来的直接写样式名称字符串的方式方便，怎么解决这个问题呢？

**方法**：由于第三方发布的样式文件一般都是css后缀，所以我们可以将自己的样式文件改为后缀为scss，然后在scss后缀的文件上配置“样式模块化”，在css后缀文件上不配置样式模块化配置。

这种做法需要安装scss后缀文件的loader：

```shell
cnpm i sass-loader node-sass -D
```

## 5. 改进自己样式表

为了解决4中提到的问题：

将自己的样式表定义为.scss文件，而第三方的样式表都是以.css结尾的。
